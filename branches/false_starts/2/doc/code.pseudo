class Game
  has_many :seats do
    def [](slot)
      find_by_slot(slot)
    end
  end

  has_one :building_supply
  has_one :currency_supply
  has_one :building_market
  has_one :currency_market
  belongs_to :active_seat # doesn't really "belong to", but this sets up the right direction association

  before_create :setup_game

  def phase=(new_phase)
    if self.phase == "pregame" && new_phase == "active"
      occupied_seats, open_seats = seats.partition{ |seat| seat.player.nil? }
      unless occupied_seats.size >= 3
        raise ArgumentError, "cannot setup game unless at least three players are seated"
      end
      open_seats.each{ |seat| seat.destroy }
      occupied_seats.each do |seat|
        currency_supply.starting_hand(seat.player.hand)
      end
      currency_market.refill_from(currency_supply)
      currency_supply.add_score_cards
      building_market.refill_from(building_supply)
      self.active_seat = occupied_seats.sort do |seatA, seatB|
        [ (seatA.hand.size <=> seatB.hand.size),
          (seatA.hand.value <=> seatB.hand.value),
          rand <=> 0.5 ].detect{ |criteria| !criteria.zero? } || 0
      end.first
    end
    write_attribute("phase", new_phase)
  end

private
  def setup_game
    (1..6).each{ |i| seats.build(:slot => i) }
    self.building_supply.build
    self.currency_supply.build
    self.building_market.build
    self.currency_market.build
    self.phase = "pregame"
  end
end

class Seat
  belongs_to :game
  has_one :alhambra
  has_one :reserve
  has_one :hand

  before_create :setup_seat

private
  def setup_seat
    self.score = 0
    self.alhambra.build
    self.reserve.build
    self.hand.build
  end
end

class Alhambra
  belongs_to :seat
  has_many :building_placements
  has_many :buildings, :through => :building_placements

  before_create :setup_alhambra

private
  def setup_alhambra
    center = building_placements.build(:x => 0, :y => 0)
    center.building.build(:type => "lion", :walls => 0)
  end
end

class Reserve
  belongs_to :seat
  has_many :buildings, :through => :reserves_buildings
end

class Hand
  belongs_to :seat
  has_many :cards, :through => :hands_cards
end

class BuildingSupply
  belongs_to :game
  has_many :buildings, :through => :building_supplies_buildings

  before_create :setup_building_supply

private
  def setup_building_supply
    building_templates = YAML.load("buildings.yml")
    buildings = building_templates.map do |template|
      seat.game.buildings.build(template)
    end
    buildings.shuffle
    buildings.each{ |building| self.buildings << building }
  end
end

class CurrencySupply
  belongs_to :game
  has_many :cards, :through => :currency_supplies_cards

  before_create :setup_currency_supply

private
  def setup_currency_supply
    card_templates = YAML.load("cards.yml")
    cards = card_templates.map do |template|
      seat.game.cards.build(template)
    end
    cards.shuffle
    cards.each{ |card| self.cards << card }
  end
end

class BuildingMarket
  belongs_to :game
  has_many :building_offerings

  before_create :setup_building_market

private
  def setup_building_market
    [ :denar, :dirham, :dukat, :florin ].each do |currency|
      building_offerings.build(:currency => currency)
    end
  end
end

class CurrencyMarket
  belongs_to :game
  has_many :cards, :through => :currency_offerings
end

PUT /games/{game}/phase

  game = Game.find(game)
  game.phase = representation

{make comment}
POST /games/{game}/comments
- Requires authentication (no particular seat need authorization though)
* Add comment to comments stream

{take money}
POST /games/{game}/markets/currency/takings
- Requires authorization of active seat
- Requires phase "in turn"
- Requires legal card selection
* Cards are transferred from currency market to seat's hand
* End turn triggered

{buy tile}
POST /games/{game}/markets/building/purchases
- Requires authorization of active seat
- Requires phase "in turn"
- Requires tile be in building market
- Requires currency match or exceed tile cost
* Move tile from market to seat's limbo
* Move currency from hand into currency discard
- If currency exceeds tile cost
  * End turn triggered

{place tile on alhambra}
PUT /games/{game}/seats/{seat}/alhambra/x,y
- Requires x,y be valid placement location for tile
- if tile is in limbo
  - Requires x,y be empty
- else
  - Requires phase "in turn"
  - Requires that tile be in reserve
  - If x,y is not empty
    * Put tile from x,y into reserve
* Put tile at x,y
* End turn triggered

{place tile on reserve board}
POST /games/{game}/seats/{seat}/reserve
- unless tile is in limbo
  - Requires phase "in turn"
  - Requires that tile be in alhambra
  - Requires that removing tile from alhambra not leave it invalid
* Put tile into reserve
* End turn triggered

{end turn}
(Triggered internally)
* Phase set to "end turn"
- if active seat's limbo is empty
  * Building market is refilled
  * Currency market is refilled
  - Atomic
    * Next seat is designated as active seat
    * Phase set to "in turn"

{refill building market}
(triggered internally)
- if building market has an empty slot
  - if building supply is empty
    * Trigger end game
  - else
    * Move next tile from building supply into lowest slot of building market
    * Trigger refill building market

{refill currency market}
(triggered internally)
- if currency market has an empty slot
  - if currency supply is empty
    * Shuffle currency discard and replace currency market
  * Move next card from currency supply into lowest slot of currency market
  - if that card was a scoring card
    * Trigger appropriate scoring round
    * Remove that card from the game
  * Trigger refill currency market

{scoring round}
(triggered internally)
* do scoring stuff

{end game}
(Triggered internally)
* Phase set to "end game"
* Scoring round 3 triggered
* Walls are scored
* Game is marked as ended
